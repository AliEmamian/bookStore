## Description

این پروژه مدیریریت فروشگاه کتاب است.

 معماری این پروژه به این صورت است که دارای سه میکروسرویس book (برای مدیریت کتابها)  user(مدیریت اطلاعات کاربر)  و purchase (برای مدیریت خرید)  و همچنین دارای یک API Gateway به نام client می باشد که هم وظیفه گیت وی  و هم وظیفه aggregator(تجمیع کننده) رو برعهده دارد.
و یک channel rabbit برای ارتباط بین میکروسرویس ها  وجود دارد.

ارتباط کلاینت  با این سیستم فقط از طریق گیت وی می باشد. کلاینت درخواست را به گیت وی می دهد. گیت وی با توجه به درخواست (در صورت لزوم پردازش میکند و) درخواست را در صف rabbit می گذارد سپس میکروسرویس مد نظر پیام را از صف( با توجه به اطلاعات پیام) بر میدارد.پردازش های لازم رابر روی آن انجام می دهد و جواب را به گیت وی بر می گرداند.

گیت وی دارای سه ماژول(book, user, purchase) هست که برای مدیریت این درخواست ها استفاده میکند.

هر میکروسرویس شامل ۳ لایه کنترلر سرویس و ریپازیتوری هست.

## Installation


برای نصب ماژول ها کافی است به مسیر روت هرکدام از پروژه ها را رفته و دستور زیر را وارد کنید.

```bash
$ npm install
```
 

هر سه تا میکروسرویس دارای دیتابیس مونگو هستند .برای دادن اطلاعات اتصال به دیتابیس باید در مسیر روت هر کدام یک فایل .env ایجاد کنیم و اطلاعات آن را با توجه به فایل .env.template پرکنیم.
همچنین میکروسرویس user دارای یک redis هست که این اطلاعات اتصال به آن را هم باید در فایل .env مربوطه کامل کرد.

سپس دستور زیر را در مسیر روت برای اجرا در هر ۴ پروژه واردکنید

```bash
$ npm run start
```

اکسپورت فایل جیسون postman هم برای مدیریت راحت تر درخواست ها گذاشته شده است.

برای استفاده از سیستم کافی است اطلاعات چند تا کتاب را با استفاده از درخواست add book در پست من  فراخوانی کرده. 

برای دیدن اطلاعات کتاب های اضافه شده کافی است درخواست get all books را بدهیم.

 سپس باید اطلاعات یوزر را با درخواست add user اضافه کرده و در نهایت به تست عملکرد api ها  برویم.

برای دیدن اطلاعات یوزر های اضافه شده کافی است درخواست get all users را بدهیم.
## api

### serach book
برای جستجو کتاب مورد نظر استفاده می شود.یک درخواست GET هست که اطلاعات جستجو در query param ها ارسال می شود. این درخواست توسط گیت وی در صف  گذاشته می شود و میکروسرویس book این اطلاعات را برمیدارد پردازش های لازم را انجام میدهد و جواب را برمیگرداند.

### update user(premium)

کاربرها دارای دونوع normal و permium هستند که در موقع ثبت نام به صورت نرمال درنظر گرفته می شوند و حالا اگر سیستم بخواهد کاربری را premium کند باید این درخواست را ارسال کند. 
این یک درخواست با متدUPDATE است که اطلاعات شناسه کاربر در param و اطلاعات دیگر دربدنه درخواست ارسال می شود. 

ویژگی premium این است که برای تمام مبالغ پرداختی کاربر با 
10 درصد تخفیف روی قیمت کل محاسبه می شود.

### update user(add favorite)

برای افزودن کتاب ها به لیست favorite  های کاربر این درخواست ارسال می شود. 
همانند درخواست قبلی است ولی اطلاعات بدنه تفاوت می کند.
هم میتوان شناسه های کتاب ها را در این لیست ذخیره کنیم و یا میتوان نام کتاب را ذخیره کنیم.
### (remove favorites)

برای حذف کتاب از لیست favorite های کاربر استفاده می شود. متد درخواست DELETE است.

### get favorites of user
برای دریافت اطلاعات favorite های یک کاربر استفاده می شود.
در ابتدا سعی میکند این اطلاعات را از کش ردیس بگیرد و در صورتی که کش خالی بود اطلاعات از دیتابیس گرفته می شود. در موقع آپدیت لیست هم این کش آپدیت می شود.
ولی خب این کش یه مدت زمانی معتبر است که این مدت زمان در کانفیگی که به فایل .env دادیم قابل تنظیم است.
برای مدیریت ردیس هم یک ماژول نوشته شده که در هرکجالازم بود میتوانیم استفاده کنیم.


### add basket

برای افزودن یک کتاب به سبد خرید کاربر استفاده می شود.


این فرض  در نظر گرفته شده که در هر مرحله برای تغییر سبد خرید یا یک کتاب جدید اضافه می شود یا تعداد یک کتاب  موجود در سبد خرید یک عدد افزوده یا کم می شود.

برای هر سبد خرید ۴ وضعیت در نظر گرفته شده: 

۱-وضعیت incomplete  

۲- وضعیت pending

۳- وضعیت cancel

۴-وضعیت  done

هر کاربر ماکزیمم یک سبد خرید incomplete دارد. هر کتابی که اضافه یا کم می شود با این سبد کار میکند.

در صورتی که لینک درگاه را بگیرد و به صفحه درگاه برود به وضعیت pending تغییر می کند. (این قسمت به دلیل اینکه درگاه پیاده سازی نشده در پروژه در نظر گرفته نشده) و باید با یک کران جاب چک شود که اگر وضعیت خریدی برای مدتی در این وضعیت بود یک تغییر وضعیتی در سبد خرید اتفاق بیفتد.

وضعیت کنسل هم برای اینکه کلا کاربر یک سبد خرید را پاک کند در نظر گرفته شده که پیاده سازی نشده.

و در صورتی که پرداخت کامل انجام شود به وضعیت done تغییر وضعیت می دهد.

برای افزودن یه کتاب به سبد خرید سه  حالت ممکن است پیش آید.

۱- کاربر برای اولین بار است که کالایی وارد سبد خریدش می کند پس لازم است یک سبد خرید با وضعیت incomplete برایش ایجاد شود.

۲- کاربر از قبل سبد خرید داشته ولی  میخواهد کالای جدید اضافه کند.در این حالت سبد خرید با وضعیت incomplete ش آپدیت می شود.

۳- کاربر از قبل سبد خرید داشته ولی میخواهد به کالای موجود یک عدد اضافه کند.در این حالت سبد خرید با وضعیت incomplete ش آپدیت می شود.

نکته ای که وجود دارد این است که با توجه به نوع کاربر (normal, premium) تصمیم گرفته می شود که مبلغ پرداختی با ۱۰ درصد تخفیف محاسبه می شود.

### remove basket

برای کم کردن یک آیتم از سبد خرید استفاده می شود.
در این حالت اگر موجودی یک کالا در سبد خرید برابر یک باشد با کم کردن باید آن کالا هم از سبد خرید حذف شود.
درغیر اینصورت یک عدد از کالا کم میشود.
و همانند قبل با توجه به نوع کاربر قیمت ها محاسبه می شود.

### get basket

برای دریافت لیست سبد خرید استفاده می شود. ورودی این سرویس می تواند userId باشد که برای کاربر استفاده می شود. درصورتی که  سبد خرید تمام کاربران را بخواهیم ببینیم بدون ورودی این سرویس را فراخوانی میکنیم.که این در واقع برای ادمین است.

## generate payment link
در صورتی که کاربر بخواهد سبد خرید ش را نهایی کند و  پرداخت را انجام دهد. این سرویس را فراخوانی میکند.
که در واقع باید از اطلاعات درگاه مقادیری مثل authority را بگیرد و لینک پرداخت را بسازد ولی چون این قسمت پیاده سازی نشده یک اینترفیس  ساخته شده که این کلاس سرویس ان را باید پیاده سازی کندو با توجه به اطلاعات درگاه باید آن ها را پرکند. اما چون درگاه نداریم یک مقدار تستی برمیگرداند.
ورودی های آن userId, callbackUrl , amount  می باشد.
و این اطلاعات authority  را در سبد خرید اضافه یا آپدیت میکند.
## callbak gateway

درنهایت بعد از پرداخت موفق این سرویس توسط درگاه باید فراخوانی شود.دو تا ورودی authority , isOk دارد که  وضعیت پرداخت کاربر را نشان می دهد.
درنهایت اگر پرداخت موفق بود باید آنرا وریفای کنیم و اطمینان پیداکنیم که این درخواست از سمت درگاه امده. و درنهایت وضعیت سبد خرید را done کنیم 